##                   微信小程序底层框架实现原理

### 一、小程序与h5页面的区别

- 运行环境：小程序基于浏览器内核重构的内置解析器，而 `h5` 的宿主环境是浏览器。所以小程序中没有 `DOM` 和 `BOM` 的相关 `API` ， `jQuery` 和一些 `NPM` 包都不能在小程序中使用； 网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView 。而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的，如下图所示

  ![小程序的运行环境](https://picfile-baidu.babybus.com/ActivityData/BabyBusFile/20211020/a2a42713b38149848cac338e6f98e11e.jpg)

  

- 系统权限：小程序能获得更多的系统权限，如网络通信状态、数据缓存能力等；

- 渲染机制：小程序的逻辑层和渲染层是分开的，而 `h5` 页面 `UI` 渲染跟 `JavaScript` 的脚本执行都在一个单线程中，互斥。所以 `h5` 页面中长时间的脚本运行可能会导致页面失去响应。

### 二、双线程模型

- 小程序的架构模型有别与传统web单线程架构，小程序为双线程架构。微信小程序的渲染层与逻辑层分别由两个线程管理，渲染层的界面使用 `webview` 进行渲染；逻辑层采用 `JSCore`运行`JavaScript`代码。

![整体架构](https://picfile-baidu.babybus.com/ActivityData/BabyBusFile/20211020/87b139311526473b830c410b01b886b5.png)

- 由于渲染层与逻辑层分开，一个小程序有多个界面，所以渲染层对应存在多个`webview`。这两个线程之间由`Native`层进行统一处理。无论是线程之间的通讯、数据的传递、网络请求都由Native层做转发。

- 视图层和逻辑层通过系统层的 `WeixinJsBridage` 进行通信：逻辑层把数据变化通知到视图层，触发视图层页面更新，视图层把触发的事件通知到逻辑层进行业务处理。

  （页面渲染的具体流程是：在渲染层，宿主环境会把 `WXML` 转化成对应的 `JS` 对象，在逻辑层发生数据变更的时候，我们需要通过宿主环境提供的 `setData` 方法把数据从逻辑层传递到渲染层，再经过对比前后差异，把差异应用在原来的Dom树上，渲染出正确的UI界面）

### 三、[组件系统Exparser框架](https://developers.weixin.qq.com/ebook?action=get_post_info&docid=0000aac998c9b09b00863377251c0a)

Exparser是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由Exparser组织管理。

Exparser的组件模型与[WebComponents](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components)标准中的ShadowDOM高度相似。Exparser会维护整个页面的节点树相关信息，包括节点的属性、事件绑定等，相当于一个简化版的Shadow DOM实现。Exparser的主要特点包括以下几点：

- 基于Shadow DOM模型：模型上与WebComponents的ShadowDOM高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他API以支持小程序组件编程。
- 可在纯JS环境中运行：这意味着逻辑层也具有一定的组件树组织能力。
- 高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。

